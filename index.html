
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>Joywii`s Blog</title>
	<meta name="author" content="Joywii">

	
	<meta name="description" content="Mar 26th, 2016 AutoLayout进阶 零、参考文档 布局过程
先进的自动布局工具箱(中文)
先进的自动布局工具箱(英文)
Auto Layout Guide 一、布局过程 在AutoLayout下，视图的布局过程： updating constraints: &hellip;">
	

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="/atom.xml" rel="alternate" title="Joywii`s Blog" type="application/atom+xml">
	
	<link rel="canonical" href="http://Joywii.github.io/">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	<link href='http://fonts.googleapis.com/css?family=Open+Sans:400italic,400,700' rel='stylesheet' type='text/css'>
	
</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><div class="profilepic">	
	<script src="/javascripts/md5.js"></script>
	<script type="text/javascript">
		document.write("<img src='http://www.gravatar.com/avatar/" + MD5("kingzwt@126.com") + "?s=160' alt='Profile Picture' style='width: 160px;' />");
	</script>
</div>
<h1><a href="/">Joywii`s Blog</a></h1>
<p class="subtitle">iOS Dev And Stu Blog</p>
<nav id="main-nav"><ul class="main">
    <li><a href="/">首页</a></li>
    <li><a href="http://weibo.com/kingzwt">微博</a></li>
    <li><a href="/blog/archives">所有文章</a></li>
</ul>
</nav>
<nav id="sub-nav">
	<div class="social">
		
		<a class="weibo" href="http://www.weibo.com/kingzwt" title="Weibo">Weibo</a>
		
		
		
		
		
		<a class="github" href="https://github.com/Joywii" title="GitHub">GitHub</a>
		
		
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
</nav>
<!--
<h1><a href="/">Joywii`s Blog</a></h1>
-->

</header>				
			</div>
		</div>	
		<div class="mid-col">
			
				
			
			<div class="mid-col-container">
				<div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2016-03-26T20:39:59+08:00" data-updated="true" itemprop="datePublished">Mar 26<span>th</span>, 2016</time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2016/03/26/autolayoutjin-jie/" itemprop="url">AutoLayout进阶</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h4>零、参考文档</h4>

<ul>
<li><a href="http://stackoverflow.com/questions/20609206/setneedslayout-vs-setneedsupdateconstraints-and-layoutifneeded-vs-updateconstra">布局过程</a></li>
<li><a href="http://objccn.io/issue-3-5/">先进的自动布局工具箱(中文)</a></li>
<li><a href="https://www.objc.io/issues/3-views/advanced-auto-layout-toolbox/">先进的自动布局工具箱(英文)</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/index.html#//apple_ref/doc/uid/TP40010853-CH7-SW1">Auto Layout Guide</a>

<h4>一、布局过程</h4>

<p>在AutoLayout下，视图的布局过程：
<img src="http://i.stack.imgur.com/i9YuN.png" alt="Alt text" /></p></li>
<li><code>updating constraints:</code>
这个过程是我们根据一些条件更新、新增、删除视图的约束的地方。这个过程之后所有的视图约束就都创建好了，后续会根据现有的约束计算布局。</li>
<li><code>update layout:</code>
这个过程真正计算布局的地方，系统根据约束计算好之后我们还可以在<code>layoutSubviews</code>内做一些自定义的布局。

<blockquote><p><strong><code>重要事项</code></strong>
&ndash; <code>setNeedsUpdateConstraints:</code>是标记视图为需要更新约束，保证调用<code>updateConstraintsIfNeeded</code>的时候系统调用<code>updateConstraints</code>,或者系统在下一个运行循环（Runloop）的时候调用<code>updateConstraints</code>。
&ndash; <code>setNeedsLayout:</code>是标记视图为需要重新布局，保证调用<code>setNeedLayout</code>的时候系统调用<code>layoutSubviews</code>,或者系统在下一个运行循环管（Runloop）的时候调用<code>layoutSubviews</code>。
&ndash; 任何对视图约束的操作（更新、新增、删除）之后都会自动调用<code>setNeedLayout</code>，就会在下一个运行循环（Runloop）或者我们自己调用<code>layoutIfNeed</code>的时候调用<code>layoutSubviews</code>。</p></blockquote></li>
</ul>


<h4>二、固有内容尺寸（Intrinsic Content Size ）</h4>

<p>固有内容尺寸是一个视图期望为其显示特定内容得到的大小。<code>UILabel</code>会根据字体和内容自己计算一个固有大小，多行文本的时候可以设置<code>preferredMaxLayoutWidth</code>来计算多行文本的固有大小。<code>UIView</code>没有固有大小，但是我们可以重写<code>intrinsicContentSize</code>,根据视图的内容自己计算视图的固有大小。</p>

<h4>三、压缩阻力（Compression Resistance） 吸附阻力（ Content Hugging）</h4>

<ul>
<li><code>contentCompression:</code>阻止自己被压缩的优先级，如果两个两个视图出现相互挤压的时候，优先级高的不会被压缩，优先级底的被压缩。例如：当两个<code>UILabel</code>水平相互压缩的时候，我们可以指定不想压缩的<code>UILabel</code>的阻止压缩的优先级高一点。</li>
<li><code>contentHugging:</code>阻止自己被吸附的优先级，当一个视图的<code>Frame</code>改变的时候，可以导致另外一个依赖此视图的视图布局发生改变，设置阻止吸附优先级高一点，可以阻止这个改变。

<blockquote><p><strong>优先级(我们可以自己设定值 eg：500)</strong>
UILayoutPriorityRequired  = 1000
UILayoutPriorityDefaultHigh  = 750
UILayoutPriorityDefaultLow = 250
UILayoutPriorityFittingSizeLevel = 50</p></blockquote></li>
</ul>


<h4>四、Alignment Rect</h4>

<p><code>AutoLayout</code>中的约束都是基于<code>Alignment Rect</code>进行后面的布局计算的。一般情况下我们不做任何处理<code>Alignment Rect</code>是和<code>Frame</code>一样的。<code>Alignment Rect</code>是要我们指定视图的要基于的核心元素的大小。
比如，一个自定义 icon 类型的按钮比我们期望点击目标还要小的时候，这将会很难布局。当插图显示在一个更大的 frame 中时，我们将不得不了解它显示的大小，并且相应调整按钮的 frame，这样 icon 才会和其他界面元素排列好。当我们想要在内容的周围绘制像 badges、阴影、倒影的装饰时，也会发生同样的情况。通过重写以下方法可以指定视图的<code>Alignment Rect</code>。</p>

<ul>
<li>alignmentRectInsets：</li>
<li>alignmentRectForFrame:</li>
<li>frameForAlignmentRect:（<code>要和alignmentRectForFrame可逆</code>）</li>
</ul>


<h4>五、AutoLayout动画</h4>

<p>只有在动画过程中触发视图的重新布局<code>layoutSubviews</code>才会有动画效果。一般我们先修改视图的约束，系统会自动调用<code>setNeedLayout</code>，然后我们要做的就是在动画过程中调用<code>layoutIfNeed</code>触发系统调用<code>layoutSubviews</code>.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>self.constraint.offset = 80;
</span><span class='line'>[UIView animateWithDuration:1.0f animations:^{
</span><span class='line'>    [self setNeedsLayout];
</span><span class='line'>}];</span></code></pre></td></tr></table></div></figure>


<h4>六、AutoLayout调试</h4>

<h5>1. 不可满足的约束条件</h5>

<p>当因为有不满足约束条件而抛出异常的时候，我们可以打上断点，如果不是很明确是哪个视图导致的问题，你就需要通过内存地址来辨认视图：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(lldb) po [[0x7731880 superview] recursiveDescription]
</span><span class='line'>$3 = 0x07117ac0 &lt;UIView: 0x7730fe0; frame = (32 128; 259 604); layer = &lt;CALayer: 0x7731150&gt;&gt;
</span><span class='line'>   | &lt;UIView: 0x7731880; frame = (90 -50; 80 100); layer = &lt;CALayer: 0x7731450&gt;&gt;
</span><span class='line'>   | &lt;UIView: 0x7731aa0; frame = (90 101; 80 100); layer = &lt;CALayer: 0x7731c60&gt;&gt;</span></code></pre></td></tr></table></div></figure>


<p>一个更直观的方法是在控制台修改有问题的视图，这样你可以在屏幕上标注出来。比如，你可以改变它的背景颜色：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(lldb) expr ((UIView *)0x7731880).backgroundColor = [UIColor purpleColor]</span></code></pre></td></tr></table></div></figure>


<p>然后从断点处继续执行，就可以看到效果。
你也可以通过改进错误信息本身，来更容易地在 iOS 中弄懂不可满足的约束条件错误到底在哪里。我们可以在一个 category 中重写 NSLayoutConstraint 的描述，并且将视图的 tags 包含进去：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@implementation NSLayoutConstraint (AutoLayoutDebugging)
</span><span class='line'>#ifdef DEBUG
</span><span class='line'>- (NSString *)description
</span><span class='line'>{
</span><span class='line'>    NSString *description = super.description;
</span><span class='line'>    NSString *asciiArtDescription = self.asciiArtDescription;
</span><span class='line'>    return [description stringByAppendingFormat:@" %@ (%@, %@)", 
</span><span class='line'>        asciiArtDescription, [self.firstItem tag], [self.secondItem tag]];
</span><span class='line'>}
</span><span class='line'>#endif
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>如果整数的 tag 属性信息不够的话，我们还可以得到更多新奇的东西，并且在视图类中增加我们自己命名的属性，然后可以打印到错误消息中。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface UIView (AutoLayoutDebugging)
</span><span class='line'>- (void)setAbc_NameTag:(NSString *)nameTag;
</span><span class='line'>- (NSString *)abc_nameTag;
</span><span class='line'>@end
</span><span class='line'>@implementation UIView (AutoLayoutDebugging)
</span><span class='line'>- (void)setAbc_NameTag:(NSString *)nameTag
</span><span class='line'>{
</span><span class='line'>    objc_setAssociatedObject(self, "abc_nameTag", nameTag, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
</span><span class='line'>}
</span><span class='line'>- (NSString *)abc_nameTag
</span><span class='line'>{
</span><span class='line'>    return objc_getAssociatedObject(self, "abc_nameTag");
</span><span class='line'>}
</span><span class='line'>@end
</span><span class='line'>@implementation NSLayoutConstraint (AutoLayoutDebugging)
</span><span class='line'>#ifdef DEBUG
</span><span class='line'>- (NSString *)description
</span><span class='line'>{
</span><span class='line'>    NSString *description = super.description;
</span><span class='line'>    NSString *asciiArtDescription = self.asciiArtDescription;
</span><span class='line'>    return [description stringByAppendingFormat:@" %@ (%@, %@)", asciiArtDescription, [self.firstItem abc_nameTag], [self.secondItem abc_nameTag]];
</span><span class='line'>}
</span><span class='line'>#endif
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>另外还有一个打印调试信息的方法：
<a href="https://github.com/objcio/issue-3-auto-layout-debugging/blob/master/NSLayoutConstraint%2BDebugging.m">issue-3-auto-layout-debugging</a></p>

<h5>2. 有歧义的布局</h5>

<p>UIView提供了三种方式来查明有歧义的布局：<code>hasAmbiguousLayout</code>，<code>exerciseAmbiguityInLayout</code>，和私有方法 <code>_autolayoutTrace</code>。如果我们不想自己遍历视图层并记录这个值，可以使用私有方法 _autolayoutTrace。这将返回一个描述整个视图树的字符串：类似于 recursiveDescription 的输出（当视图存在有歧义的布局时，这个方法会告诉你）。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@implementation UIView (AutoLayoutDebugging)
</span><span class='line'>- (void)printAutoLayoutTrace {
</span><span class='line'>    #ifdef DEBUG
</span><span class='line'>    NSLog(@"%@", [self performSelector:@selector(_autolayoutTrace)]);
</span><span class='line'>    #endif
</span><span class='line'>}
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>另一个标识出有歧义布局更直观的方法就是使用 exerciseAmbiguityInLayout。这将会在有效值之间随机改变视图的 frame。然而，每次调用这个方法只会改变 frame 一次。所以当你启动程序的时候，你根本不会看到改变。创建一个遍历所有视图层级的辅助方法是一个不错的主意，并且让所有包含歧义布局的视图<code>晃动</code>。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@implementation UIView (AutoLayoutDebugging)
</span><span class='line'>- (void)exerciseAmiguityInLayoutRepeatedly:(BOOL)recursive {
</span><span class='line'>    #ifdef DEBUG
</span><span class='line'>    if (self.hasAmbiguousLayout) {
</span><span class='line'>        [NSTimer scheduledTimerWithTimeInterval:.5
</span><span class='line'>                                     target:self
</span><span class='line'>                                   selector:@selector(exerciseAmbiguityInLayout)
</span><span class='line'>                                   userInfo:nil
</span><span class='line'>                                    repeats:YES];
</span><span class='line'>    }
</span><span class='line'>    if (recursive) {
</span><span class='line'>        for (UIView *subview in self.subviews) {
</span><span class='line'>            [subview exerciseAmbiguityInLayoutRepeatedly:YES];
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    #endif
</span><span class='line'>} 
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<h5>3. NSUserDefault选项</h5>

<p>有几个有用的 NSUserDefault 选项可以帮助我们调试、测试自动布局：
&ndash; <code>UIViewShowAlignmentRects</code>: 设置视图可见的<code>alignment rects</code>。
&ndash; <code>NSDoubleLocalizedStrings</code>: 简单的获取并复制每个本地化的字符串。这是一个测试更长语言布局的好方法。
&ndash; <code>AppleTextDirection</code> 和 <code>NSForceRightToLeftWritingDirection</code>: 模拟从右到左的语言</p>

<p>我们可以通过<code>代码</code>和<code>scheme editor</code>设置。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[[NSUserDefaults standardUserDefaults] setBool:YES forKey:@"NSDoubleLocalizedStrings"];</span></code></pre></td></tr></table></div></figure>


<p><img src="http://img.objccn.io/issue-3/NSDoubleLocalizedStrings.png" alt="Alt text" /></p>

<h4>七、AutoLayout性能</h4>

<p>自动布局是布局过程中额外的一个步骤。它需要一组约束条件，并把这些约束条件转换成 frame。因此这自然会产生一些性能的影响。如果我们对一些复杂的视图的性能要求比较高，就避免通过约束来布局，<code>直接通过计算视图的frame来布局。</code></p>

<h4>八、总结</h4>

<p>自动布局是一个帮助我们灵活布局的工具，我们熟悉了以上这些自动布局的知识后，在UI布局层面会给我们很多乐趣。</p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2016-03-02T15:31:09+08:00" data-updated="true" itemprop="datePublished">Mar 2<span>nd</span>, 2016</time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2016/03/02/iosqian-ming-shou-quan-ji-zhi/" itemprop="url">iOS签名授权机制</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h4>几个重要的概念</h4>

<h5>1. 非对称加密</h5>

<p>非对称加密算法需要两个密钥：<code>公开密钥（publickey</code>）和<code>私有密钥（privatekey）</code>。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。（私钥是要保密的，公钥可以公开）
<code>RSA</code>是目前最有影响力的公钥加密算法，它能够抵抗到目前为止已知的绝大多数密码攻击，已被ISO推荐为公钥数据加密标准。<code>RSA</code>是以三个发明者的姓氏首字母组成的。</p>

<h5>2. 摘要算法</h5>

<p>数据摘要算法是密码学算法中非常重要的一个分支，它通过对所有数据提取指纹信息以实现数据签名、数据完整性校验等功能，由于其不可逆性，有时候会被用做敏感信息的加密。数据摘要算法也被称为哈希（Hash）算法、散列算法。
摘要算法也可以理解为将任意长度的数据，通过一个算法，得到一个固定长度的数据。典型的摘要算法，比如大名鼎鼎的<code>MD5</code>和<code>SHA</code>。</p>

<h5>3. 数字签名</h5>

<p>数字签名就是利用<code>非对称加密</code>和<code>摘要算法</code>来传输数据，保证数据的<code>完整性</code>和<code>合法性</code>。验证过程如下：
1. 发送方使用给一个摘要算法（<code>MD5</code>）得到要发送数据的摘要，然后用自己的私钥和一个非对称加密算法（<code>RSA</code>）对得到的摘要加密，得到加密后的数据，然后将<code>要发送的数据</code>、<code>加密后的数据</code>、<code>摘要算法</code>和<code>加密算法</code>一同发送给接收方。
2. 接收方接收到数据后，根据指定的摘要算法（<code>MD5</code>）得到实际要传输的数据的摘要，然后在根据指定的加密算法（<code>RSA</code>）和已有的公钥解密得到加密数据解密后的数据，最后比较解密后的数据和得到的摘要是否相同，如果相同就说明实际要传输的数据是完成的合法的。</p>

<p><img src="http://img.itc.cn/photo/o41PBy3DAqp" alt="" /></p>

<h5>4. 数字证书</h5>

<p>数字证书就是通过数字签名方式来传输的一段数据，iOS开发中的数字证书是Apple Worldwide Developer Relations Certification Authority(WWDR)证书认证中心数字签名过的数据，表面上我们看到的就是钥匙串中的证书，实际WWDR数字签名后的证书包含以下内容：</p>

<blockquote><ul>
<li>用户的公钥</li>
<li>用户信息</li>
<li>证书机构名称</li>
<li>证书有效期</li>
<li><strong>苹果数字签名 ： 用于验证以上信息</strong></li>
</ul>
</blockquote>

<h4>iOS签名验证流程</h4>

<p>整个过程的前提是已经购买了苹果的开发者账号（\$99或\$299）。并且安装了<code>Xcode</code>，因为安装<code>Xcode</code>的过程中会自动安装苹果的开发者根证书（<code>Apple Worldwide Developer Relations Certification Authority</code>）。这证书包含了苹果CA的<code>公钥</code>。有了这个公钥，我们和Apple就可以进行互信的信息传递。整个过程大致如下：</p>

<p><img src="http://img.itc.cn/photo/j41PB2NQfCg" alt="" /></p>

<h5>一. 证书申请</h5>

<ol>
<li><p>用我们自己的机器生成<code>CertificateSigningRequest.certSigningRequest</code>文件，在生成的过程中会产生一对公钥和私钥，私钥已经保存在我们的机器上，这个文件包含了我们的公钥，具体内容如下：</p>

<blockquote><ul>
<li>申请者信息，此信息是用申请者的<code>私钥</code>加密的。</li>
<li>申请者公钥，此信息是申请者使用的<code>私钥</code>对应的公钥。</li>
<li>摘要算法和公钥加密算法</li>
</ul>
</blockquote></li>
<li><p>上传<code>CertificateSigningRequest.certSigningRequest</code>到<code>MemberCenter</code>。<code>MemberCenter</code>根据获取到的<code>公钥</code>和我们的用户信息，通过<code>Apple</code>自己的私钥进行数字签名生成证书，这个证书可以通过安装<code>Xcode</code>过程中安装的根证书进行验证。具体证书包含内容如下：</p>

<blockquote><ul>
<li>用户的公钥</li>
<li>用户信息</li>
<li>证书机构名称</li>
<li>证书有效期</li>
<li><strong>苹果数字签名 ： 通过根证书验证以上信息</strong></li>
</ul>
</blockquote></li>
<li><p>下载生成的证书，双击安装就会出现在<code>钥匙串</code>中，<code>钥匙串</code>会根据证书中的公钥对应上本机器上的私钥。</p></li>
</ol>


<p><img src="http://img.itc.cn/photo/j41PBVh1nJ1" alt="" /></p>

<h5>二. 打包签名</h5>

<ol>
<li><p>在<code>MemberCenter</code>上生成<code>mobileprovision</code>下载安装，<code>mobileprovision</code>包含如下信息：</p>

<blockquote><ul>
<li><strong>appid：</strong>每个<code>app</code>在 <code>MemberCenter</code>创建的对应的<code>id</code>。</li>
<li><strong>包含哪些证书：</strong>不同证书对应不同功能。</li>
<li><strong>功能授权列表</strong></li>
<li><strong>可安装的设备列表：</strong>iOS设备的UDID列表，发布证书应该是通配。</li>
<li><strong>苹果数字签名：</strong>苹果用来验证以上的信息。</li>
</ul>
</blockquote></li>
<li><p>通过<code>Xcode</code>指定要使用的证书，其实是 指定了签名过程中要使用的<code>私钥</code>，这个私钥是和证书中的公钥相对应的。然后指定对应的<code>mobileprovision</code>，由于<code>mobileprovision</code>文件中包含了证书，实际上本地证书就是<code>Xcode</code>用来指定对应<code>私钥</code>用的。</p></li>
<li>最后通过指定的私钥对需要签名的数据进行数字签名（编译过程在签名之前，这里省略了编译过程，编译后的二进制文件也是要签名的内容），最终将<code>ipa</code>包的形式输出，<code>ipa</code>的文件结构如下：</li>
</ol>


<p><img src="http://img.itc.cn/photo/j41PB96mIrt" alt="" /></p>

<blockquote><ul>
<li><strong>资源文件：</strong>例如图片、html、等等。</li>
<li><strong>_CodeSignature/CodeResources：</strong>plist文件，内容是包内所有数据的数字签名。</li>
<li><strong>可执行文件：</strong>编译后的二进制文件。</li>
<li><strong>mobileprovision：</strong>我们之前通过Xcode指定的包含了证书的文件。</li>
<li><strong>Frameworks：</strong>程序引用的非系统自带的Frameworks。每个Framework的结构跟app其实差不多</li>
</ul>
</blockquote>

<h5>三. 验证安装</h5>

<ol>
<li>解压<code>ipa</code>包，获取<code>embedded.mobileprovision</code>，通过设备上的<code>Apple</code>公钥验证该文件的完整性和安全性。</li>
<li><code>embedded.mobileprovision</code>文件验证通过，获取该文件内的用户证书，再通过设备上的<code>Apple</code>公钥验证该证书的完整性和安全性。</li>
<li>证书验证通过后，获取证书内的我们开发者的公钥。然后通过开发者的公钥验证应用程序包内的数据的完整性和安全性。通过后即可安装。</li>
</ol>


<h4>参考资料</h4>

<ol>
<li><a href="http://www.pchou.info/ios/2015/12/14/ios-certification-and-code-sign.html">漫谈iOS程序的证书和签名机制</a></li>
<li><a href="http://foggry.com/blog/2014/10/16/ios-code-signing-xue-xi-bi-ji/">iOS Code Signing 学习笔记</a></li>
<li><a href="https://www.objc.io/issues/17-security/inside-code-signing/">Inside Code Signing</a></li>
<li><a href="http://objccn.io/issue-17-2/">代码签名探析</a></li>
<li><a href="https://github.com/maciekish/iReSign">iReSign</a></li>
</ol>


		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2015-03-17T10:42:55+08:00" data-updated="true" itemprop="datePublished">Mar 17<span>th</span>, 2015</time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2015/03/17/ioszhong-de-hit-testing/" itemprop="url">iOS中的Hit-Testing</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>译自:<a href="http://smnh.me/hit-testing-in-ios/">Hit-Testing in iOS</a></p>

<p>Hit-Testing是判定与一个点（touch-point）相交互的绘制在屏幕上的图像对象（<code>UIView</code>）的过程。iOS使用Hit-Testing来决定那个<code>UIView</code>是位于手指下面最前面的视图，该视图应该来接收触摸事件。Hit-Testing是通过反向的深度优先搜索算法实现的。</p>

<p>在解释Hit-Testing是如何工作之前，理解Hit-Testing何时执行是很重要的。下面的图片解释了一个简单的触摸事件的过程，从手指触摸到屏幕的一刻起到手指离开屏幕。
<img src="http://smnh.me/images/hit-test-touch-event-flow.png" alt="" />
正如上图解释的一样，Hit-Testing是在每次手指触摸时执行的。并且是在任何视图或者手势收到<code>UIEvent</code>（代表触摸属于的事件）之前。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>注意：不知道什么原因，Hit-Testing会执行多次，但是确定的`hit-test`视图是一样的</span></code></pre></td></tr></table></div></figure>


<p>在Hit-Testing完成和在触摸点下最前端的视图确认下来之后，<code>hit-test</code>会被关联所有触摸事件各个阶段（<code>begin</code>,<code>moved</code>,<code>ended</code>,<code>canceled</code>）的<code>UITouch</code>对象。除了<code>hit-test</code>视图，绑定到该视图的任何手势识别器和他的祖先视图都会关联到<code>UITouch</code>对象。然后，<code>hit-test</code>视图开始接收触摸事件的序列。</p>

<p>一个需要注意的重要的事情是即使手指移动出了<code>hit-test</code>视图的边界到了另外一个视图,<code>hit-test</code>视图任然继续接收所有的触摸事件直到触摸事件结束。</p>

<blockquote><p>“触摸对象在整个生命周期内都关联他的<code>hit-test</code>视图，即使触摸移动到了这个视图的外面”  <a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html#//apple_ref/doc/uid/TP40009541-CH4-SW4">Event Handling Guide for iOS, iOS Developer Library</a></p></blockquote>

<p>正如前面提到的Hit-Testing采用深度优先的反序访问迭代算法（先访问根节点然后从高到低访问低节点）。这种遍历方法可以减少遍历迭代的次数，一旦找到最深的包含触摸点的后裔视图就停止遍历。这是可能的因为子视图总是渲染在父视图的前面和兄弟节点中在数组中靠后的视图渲染在靠前的视图前面。所以当多个视图包含指定的点的时候，最右边子树的最深视图就是最前面的视图。</p>

<blockquote><p>可见的是子视图的内容模糊了所有父视图的内容。每一个父视图存储他的子视图于一个有序的数组中，在数组中的顺序会影响子视图的显示。如果两个兄弟视图相互覆盖，后加入的视图（存储在子视图数组的后面）出现在另一个的上面。 <a href="https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/WindowsandViews/WindowsandViews.html#//apple_ref/doc/uid/TP40009503-CH2-SW24">View Programming Guide for iOS, iOS Developer Library</a></p></blockquote>

<p>下图显示了一个视图层次树的例子和对应的绘制在屏幕上的UI。树的叶节点从左到右反映出子视图数组的排序。</p>

<p><img src="http://smnh.me/images/hit-test-view-hierarchy.png" alt="" /></p>

<p>正如看到的，“View A”和“View B”和他们的子视图，“View A.2”和“View B.1”是重叠的。由于“View B”比“View A”有一个较高的子视图索引，所以“View B”和他的子视图被渲染在“View A”和他的子视图上面。因此，“View B.1”应该被<code>hit-testing</code>返回当用户的手指触摸在&#8221;View B.1&#8221;和“View A.2”的重叠区域。</p>

<p>通过深度优先的反向遍历允许一旦找到第一个最深的后裔包含触摸点的视图就停止遍历：</p>

<p><img src="http://smnh.me/images/hit-test-depth-first-traversal.png" alt="" /></p>

<p>遍历算法以向<code>UIWindow</code>（视图层次结构的根视图）发送<code>hitTest:withEvent:</code>消息开始。这个方法返回的值就是包含触摸点的最前面的视图。</p>

<p>下面流程图说明了<code>hit-test</code>逻辑。</p>

<p><img src="http://smnh.me/images/hit-test-flowchart.png" alt="" /></p>

<p>下面的代码显示了原生的<code>hitTest:withEvent:</code>方法的可能实现方式：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {
</span><span class='line'>    if (!self.isUserInteractionEnabled || self.isHidden || self.alpha &lt;= 0.01) {
</span><span class='line'>        return nil;
</span><span class='line'>    }
</span><span class='line'>    if ([self pointInside:point withEvent:event]) {
</span><span class='line'>        for (UIView *subview in [self.subviews reverseObjectEnumerator]) {
</span><span class='line'>            CGPoint convertedPoint = [subview convertPoint:point fromView:self];
</span><span class='line'>            UIView *hitTestView = [subview hitTest:convertedPoint withEvent:event];
</span><span class='line'>            if (hitTestView) {
</span><span class='line'>                return hitTestView;
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>        return self;
</span><span class='line'>    }
</span><span class='line'>    return nil;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>hitTest:withEvent:</code>方法首先检查视图是否允许接收触摸事件。视图允许接收触摸事件的条件是：</p>

<ul>
<li>视图不是隐藏的:  <code>self.hidden == NO</code></li>
<li>视图是允许交互的:  <code>self.userInteractionEnabled == YES</code></li>
<li>视图透明度大于0.01:  <code>self.alpha &gt; 0.01</code></li>
<li>视图包含这个点:  <code>pointInside:withEvent: == YES</code></li>
</ul>


<p>然后，如果视图允许接收触摸事件，这个方法通过从后往前发送<code>hitTest:withEvent:</code>消息给每一个子视图来穿过接收者的子树，直到子视图中的一个返回<code>nil</code>。这些子视图中的第一个返回的非<code>nil</code>就是在触摸点下面的最前面的视图，被接收者返回。如果所有的子视图都返回<code>nil</code>或者接收者没有子视图返回接收者自己。</p>

<p>否则，如果视图不允许接收触摸事件，这个方法返回<code>nil</code>而根本不会传递到接收者的子树。因此，<code>hit-test</code>可能不会访问所有的视图体系结构中的视图。</p>

<h3>覆盖hitTest:withEvent:的一些用途</h3>

<p><code>hitTest:withEvent:</code>可以被覆盖，当所有触摸事件阶段的所有阶段的触摸事件想要被一个视图处理重定向到另外一个视图。</p>

<blockquote><p>因为<code>hit-test</code>仅仅在触摸事件顺序的第一次触摸事件发送给他的接收者之前（有<code>UITouchPhaseBegan</code>阶段的触摸事件），覆盖<code>hitTest:withEvent:</code>来重定向事件将要重定向所有的触摸事件。</p></blockquote>

<h4>1.增加视图的触摸区域</h4>

<p>覆盖<code>hitTest:withEvent:</code>方法的一个用途就是，当一个视图的触摸区域应该大于他的边界的时候。例如下面的插图显示了一个大小为20*20的视图。这个大小对于处理附近的触摸来说太小了。因此，他的触摸区域可以通过覆盖<code>hitTest:withEvent:</code>在每个方向增加10。</p>

<p><img src="http://smnh.me/images/hit-test-increase-touch-area.png" alt="" /></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {
</span><span class='line'>    if (!self.isUserInteractionEnabled || self.isHidden || self.alpha &lt;= 0.01) {
</span><span class='line'>        return nil;
</span><span class='line'>    }
</span><span class='line'>    CGRect touchRect = CGRectInset(self.bounds, -10, -10);
</span><span class='line'>    if (CGRectContainsPoint(touchRect, point)) {
</span><span class='line'>        for (UIView *subview in [self.subviews reverseObjectEnumerator]) {
</span><span class='line'>            CGPoint convertedPoint = [subview convertPoint:point fromView:self];
</span><span class='line'>            UIView *hitTestView = [subview hitTest:convertedPoint withEvent:event];
</span><span class='line'>            if (hitTestView) {
</span><span class='line'>                return hitTestView;
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>        return self;
</span><span class='line'>    }
</span><span class='line'>    return nil;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>注意：为了能够正确的调用`hit-test`，父视图的边界应该包含子视图希望触摸的区域，或者他的`hitTest:withEvent:`方法也应该被覆盖来包含期望的触摸区域。</span></code></pre></td></tr></table></div></figure>


<h4>2.传递触摸事件给下面的视图</h4>

<p>有的时候对于一个视图忽略触摸事件并传递给下面的视图是很重要的。例如，假设一个透明的视图覆盖在应用内所有视图的最上面。覆盖层有子视图应该相应触摸事件的一些控件和按钮。但是触摸覆盖层的其他区域应该传递给覆盖层下面的视图。为了完成这个行为，覆盖层需要覆盖<code>hitTest:withEvent:</code>方法来返回包含触摸点的子视图中的一个，然后其他情况返回<code>nil</code>，包括覆盖层包含触摸点的情况：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {
</span><span class='line'>    UIView *hitTestView = [super hitTest:point withEvent:event];
</span><span class='line'>    if (hitTestView == self) {
</span><span class='line'>        hitTestView = nil;
</span><span class='line'>    }
</span><span class='line'>    return hitTestView;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>2.传递触摸事件给子视图</h4>

<p>一个不同的使用场景可能需要父视图重定向所有的触摸事件给他唯一的子视图。这个行为是有必要的当子视图部分占据他的父视图，但是子视图应该响应所有的触摸事件包括发生在父视图上的。例如，假设一个由一个父视图和一个<code>pagingEnabled</code>设置为<code>YES</code>和<code>clipsToBounds</code>设置为<code>NO</code>（为了实现传动带的效果）的<code>UIScrollView</code>组成的图片浏览器：</p>

<p><img src="http://smnh.me/images/hit-test-pass-touches-to-subviews.png" alt="" /></p>

<p>为了使<code>UIScrollView</code>响应不发生在自己边界内但是在父视图的边界内的触摸事件，父视图的<code>hitTest:withEvent:</code>方法应该像下面这样重写：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {
</span><span class='line'>    UIView *hitTestView = [super hitTest:point withEvent:event];
</span><span class='line'>    if (hitTestView) {
</span><span class='line'>        hitTestView = self.scrollView;
</span><span class='line'>    }
</span><span class='line'>    return hitTestView;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2015-03-05T16:06:10+08:00" data-updated="true" itemprop="datePublished">Mar 5<span>th</span>, 2015</time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2015/03/05/bu-yao-zai-objective-cde-inithe-dealloczhong-xiang-zi-ji-fa-song-xiao-xi/" itemprop="url">不要在Objective-C的init和dealloc中向自己发送消息</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>译自:<a href="http://qualitycoding.org/objective-c-init/">Don’t Message self in Objective-C init (or dealloc)</a></p>

<p>在Objective-C的init和dealloc方法中向自己发送消息是有危险的，如下两个地方：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (id)initWithFoo:(id)foo
</span><span class='line'>{
</span><span class='line'>    self = [super init];
</span><span class='line'>    if (self)
</span><span class='line'>        self.something = foo;
</span><span class='line'>    return self;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)dealloc
</span><span class='line'>{
</span><span class='line'>    self.something = nil;
</span><span class='line'>    [super dealloc];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>什么时候不应该向自己发送消息</h2>

<p>通常情况下向自己发送消息都是OK的。但是在以下两个地方应该避免：</p>

<ul>
<li>在对象的创建过程中</li>
<li>在对象的销毁过程中</li>
</ul>


<p>在这两个阶段，对象处于一个中间状态。缺乏完整性。在这两个阶段调用属性方法是不合适的。因为每个方法维护着和对象相关的变量。下面是一个对象构建过程经过的流程：</p>

<ol>
<li>开始：假设对象是一致的。</li>
<li>过程中：对象状态是变动的。</li>
<li>结束：重新存储变量，对象是一致的。</li>
</ol>


<p>苹果已经有文档<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmPractical.html">Practical Memory Management</a>有一张标题 “不要在初始化方法和dealloc中调用访问方法”</p>

<h2>Objective-C init/dealloc：解决方法</h2>

<p>解决方案非常简单：在init/dealloc方法内，通过直接访问实例变量来代替通过属性方法。在非ARC下，根据属性的<code>attributes</code>是<code>retain</code>还是<code>assign</code>来写匹配代码。例如如果<code>something</code>是一个<code>retain</code>属性默认有一个<code>_something</code>实例变量，实现代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (id)initWithFoo:(id)foo
</span><span class='line'>{
</span><span class='line'>    self = [super init];
</span><span class='line'>    if (self)
</span><span class='line'>        _something = [foo retain];
</span><span class='line'>    return self;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)dealloc
</span><span class='line'>{
</span><span class='line'>    [_something release];
</span><span class='line'>    [super dealloc];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在ARC下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (id)initWithFoo:(id)foo
</span><span class='line'>{
</span><span class='line'>    self = [super init];
</span><span class='line'>    if (self)
</span><span class='line'>        _something = foo;
</span><span class='line'>    return self;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)dealloc
</span><span class='line'>{
</span><span class='line'>    [_something release];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>什么时候在init/dealloc中向自己发送消息是OK的</h2>

<p>虽然已经建议“避免在init/dealloc向自己发送消息”，但是有两个地方史OK的：</p>

<ul>
<li>init结束的地方</li>
<li>dealloc开始的地方</li>
</ul>


<p>因为在这两个地方对象是一致的。在init里所有的变量已经初始化，在dealloc还没有变量被销毁。</p>

<h5>但是我们一定谨慎和知道对象处于生命周期的什么阶段。简单的创建一个对象不应该以繁重的任务开始。保持构建和销毁方法的简洁。</h5>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-12-04T18:07:47+08:00" data-updated="true" itemprop="datePublished">Dec 4<span>th</span>, 2014</time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/12/04/iterm-plus-zshhuan-jing-da-jian/" itemprop="url">iTerm + Zsh环境搭建</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h2>1. iTerm</h2>

<p>iTerm2官方网址 <a href="http://iterm2.com/index.html">http://iterm2.com/index.html</a></p>

<h2>2. Zsh</h2>

<p>Mac系统默认安装了<code>Zsh</code>，路径是<code>/bin/zsh</code>，但是系统默认的<code>Shell</code>还是<code>Bash</code>。通过以下命令可以看到Mac系统下的所有<code>Shell</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cat /ect/shells</span></code></pre></td></tr></table></div></figure>


<p>显示如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/bin/bash
</span><span class='line'>/bin/csh
</span><span class='line'>/bin/ksh
</span><span class='line'>/bin/sh
</span><span class='line'>/bin/tcsh
</span><span class='line'>/bin/zsh</span></code></pre></td></tr></table></div></figure>


<p>把Zsh设置为当前用户的默认Shell:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>chsh -s /bin/zsh</span></code></pre></td></tr></table></div></figure>


<h3>2.1 安装配置工具oh-my-zsh</h3>

<p><code>oh-my-zsh</code>可以让我们快速的配置Zsh，话说最开始Zsh乏人问津的原因就是配置过于复杂，<code>oh-my-zsh</code>的网址是<a href="https://github.com/robbyrussell/oh-my-zsh">https://github.com/robbyrussell/oh-my-zsh</a>，安装<code>oh-my-zsh</code>只需要一条命令:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>curl -L http://install.ohmyz.sh | sh</span></code></pre></td></tr></table></div></figure>


<h3>2.2 配置别名</h3>

<p><code>zsh</code>的配置主要集中在用户当前目录的<code>.zshrc(~/.zshrc)</code>里。我主要进行了一下配置:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>alias cls='clear'
</span><span class='line'>alias ll='ls -l'
</span><span class='line'>alias la='ls -a'
</span><span class='line'>alias vi='vim'</span></code></pre></td></tr></table></div></figure>


<h3>2.2 配置颜色</h3>

<p>在<code>.zshrc</code>里找到<code>ZSH_THEME</code>，就可以设置主题了，默认主题是:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ZSH_THEME=”robbyrussell”</span></code></pre></td></tr></table></div></figure>


<p><code>oh-my-zsh</code>提供了数十种主题，相关文件在<code>~/.oh-my-zsh/themes</code>目录下，你可以随意选择，我采用了默认主题<code>robbyrussell</code>，不过做了一点小小的改动:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>PROMPT='%{$fg_bold[red]%}➜ %{$fg_bold[green]%}%p%{$fg[cyan]%}%d %{$fg_bold[blue]%}$(git_prompt_info)%{$fg_bold[blue]%}% %{$reset_color%}&gt;&gt;'
</span><span class='line'>#PROMPT='%{$fg_bold[red]%}➜ %{$fg_bold[green]%}%p %{$fg[cyan]%}%c %{$fg_bold[blue]%}$(git_prompt_info)%{$fg_bold[blue]%} % %{$reset_color%}'</span></code></pre></td></tr></table></div></figure>


<p>对照原来的版本，我把c改为d，c表示当前目录，d表示绝对路径，另外在末尾增加了一个「>>」。</p>

<h3>2.2 配置插件</h3>

<p><code>oh-my-zsh</code>项目提供了完善的插件体系，相关的文件在<code>~/.oh-my-zsh/plugins</code>目录下，默认提供了100多种，大家可以根据自己的实际学习和工作环境采用，想了解每个插件的功能，只要打开相关目录下的<code>zsh</code>文件看一下就知道了。插件也是在<code>.zshrc</code>里配置，找到<code>plugins</code>关键字，你就可以加载自己的插件了，系统默认加载<code>git</code>，我的插件配置如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>plugins=(git osx sudo python audojump)</span></code></pre></td></tr></table></div></figure>


<p>下面简单介绍几个插件:</p>

<ul>
<li>git : 当你处于一个<code>git</code>受控的目录下时，<code>Shell</code>会明确显示<code>git</code>和<code>branch</code>，另外对<code>git</code>很多命令进行了简化，例如<code>gco=’git checkout’、gd=’git diff’、gst=’git status’、g=’git’</code>等等，熟练使用可以大大减少 git 的命令长度，命令内容可以参考<code>~/.oh-my-zsh/plugins/git/git.plugin.zsh</code>。</li>
<li>osx : <code>tab</code>增强，<code>quick-look filename</code>可以直接预览文件，<code>man-preview grep</code>可以生成<code>grep</code>手册的<code>pdf</code>版本等。</li>
<li><p>autojump : <code>zsh</code>和<code>autojump</code>的组合形成了<code>zsh</code>下最强悍的插件，<code>autojump</code>会帮助我们快速的跳到我们访问过的路径，无论我们在哪里。通过以下命令安装:</p>

<p>  <code>
  brew install autojump
 </code>
然后在<code>.zshrc</code>中添加一行代码:</p>

<p>  <code>
  [[ -s ~/.autojump/etc/profile.d/autojump.sh ]] &amp;&amp; . ~/.autojump/etc/profile.d/autojump.sh
 </code></p></li>
</ul>


<h2>3. Vim</h2>

<h3>3.1 颜色配置</h3>

<p>话说最好的Vim配色方案是<a href="https://github.com/tomasr/molokai">molokai</a></p>

<ul>
<li>下载<code>molokai.vim</code>，拷贝到<code>~/.vim/colors</code>目录下，如果没有这个目录就创建这个目录。</li>
<li><p>在<code>~/.vimrc</code>中添加如下代码():</p>

<p>  <code>
colorscheme molokai
let g:molokai_original = 0
let g:rehash256 = 1
 </code></p></li>
</ul>


<p>我自己的<code>.vimrc</code>在这里<a href="https://github.com/Joywii/TerminalCon">https://github.com/Joywii/TerminalCon</a>。</p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-09-24T15:54:45+08:00" data-updated="true" itemprop="datePublished">Sep 24<span>th</span>, 2014</time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/09/24/ios8-size-classesde-li-jie-yu-shi-yong/" itemprop="url">iOS8 Size Classes的理解与使用</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h3>Size Classes是什么</h3>

<p>iOS 8在应用界面的可视化设计上添加了一个新的特性-Size Classes，对于任何设备来说，界面的宽度和高度都只分为两种描述：<code>正常</code>和<code>紧凑</code>。这样开发者便可以无视设备具体的尺寸，而是对这两类和它们的组合进行适配。这样不论在设计时还是代码上，我们都可以不再受限于具体的尺寸，而是变成遵循尺寸的视觉感官来进行适配。在Xcode中的具体体现如下图：</p>

<p><img src="http://img.itc.cn/photo/jDaZQU6AEjc" alt="Alt text" /></p>

<p>但是我们看到图中的宽度和高度都是<code>Any</code>,Any是什么意思呢？如果<code>weight</code>设为<code>Any</code>，<code>height</code>设置为<code>Regular</code>，那么在该状态下的界面元素在只要<code>height</code>为<code>Regular</code>，无论<code>weight</code>是<code>Regular</code>还是<code>Compact</code>的状态中都会存在。这种关系应该叫做继承关系，具体的四种界面描述与可继承的界面描述如下：</p>

<ul>
<li>w:Compact h:Compact 继承 (<strong>w:Any h:Compact</strong> , <strong>w:Compact h:Any</strong> , <strong>w:Any h:Any</strong>)</li>
<li>w:Regular h:Compact 继承 (<strong>w:Any h:Compact</strong> , <strong>w:Regular h:Any</strong> , <strong>w:Any h:Any</strong>)</li>
<li>w:Compact h:Regular 继承 (<strong>w:Any h:Regular</strong> , <strong>w:Compact h:Any</strong> , <strong>w:Any h:Any</strong>)</li>
<li>w:Regular h:Regular 继承 (<strong>w:Any h:Regular</strong> , <strong>w:Regular h:Any</strong> , <strong>w:Any h:Any</strong>)</li>
</ul>


<p>我们知道了iOS 8下面设备界面可以描述为4种，但是这么多设备(iPhone4S,iPhone5/5s,iPhone6,iPhone6 Plus,iPad,Apple Watch)具体对应什么描述呢？经过查看官方文档和具体实践得知具体对应关系如下:</p>

<ul>
<li>iPhone4S,iPhone5/5s,iPhone6

<ul>
<li>竖屏：(<strong>w:Compact h:Regular</strong>)</li>
<li>横屏：(<strong>w:Compact h:Compact</strong>)</li>
</ul>
</li>
<li>iPhone6 Plus

<ul>
<li>竖屏：(<strong>w:Compact h:Regular</strong>)</li>
<li>横屏：(<strong>w:Regular h:Compact</strong>)</li>
</ul>
</li>
<li>iPad

<ul>
<li>竖屏：(<strong>w:Regular h:Regular</strong>)</li>
<li>横屏：(<strong>w:Regular h:Regular</strong>)</li>
</ul>
</li>
<li>Apple Watch(猜测)

<ul>
<li>竖屏：(<strong>w:Compact h:Compact</strong>)</li>
<li>横屏：(<strong>w:Compact h:Compact</strong>)</li>
</ul>
</li>
</ul>


<h3>Size Classes手写代码</h3>

<p>为了表征<code>Size Classes</code>，Apple在iOS8中引入了一个新的类，<code>UITraitCollection</code>。这个类封装了像水平和竖直方向的Size Class等信息。iOS8的UIKit中大多数UI的基础类(包括UIScreen,UIWindow,UIViewController和UIView)都实现了<code>UITraitEnvironment</code>这个接口，通过其中的<code>traitCollection</code>这个属性，我们可以拿到对应的<code>UITraitCollection</code>对象，从而得知当前的Size Class，并进一步确定界面的布局。和UIKit中的响应者链正好相反，<code>traitCollection</code>将会在<code>view hierarchy</code>中自上而下地进行传递。对于没有指定<code>traitCollection</code>的UI部件，将使用其父节点的<code>traitCollection</code>。这在布局包含<code>childViewController</code>的界面的时候会相当有用。在<code>UITraitEnvironment</code>这个接口中另一个非常有用的是<code>-traitCollectionDidChange:</code>。在<code>traitCollection</code>发生变化时，这个方法将被调用。在实际操作时，我们往往会在<code>ViewController</code>中重写<code>-traitCollectionDidChange:</code>或者<code>-willTransitionToTraitCollection:withTransitionCoordinator:</code>方法(对于<code>ViewController</code>来说的话，后者也许是更好的选择，因为提供了转场上下文方便进行动画；但是对于普通的View来说就只有前面一个方法了)，然后在其中对当前的<code>traitCollection</code>进行判断，并进行重新布局以及动画。代码看起来大概会是这个样子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)willTransitionToTraitCollection:(UITraitCollection *)newCollection 
</span><span class='line'>              withTransitionCoordinator:(id &lt;UIViewControllerTransitionCoordinator&gt;)coordinator
</span><span class='line'>{
</span><span class='line'>    [super willTransitionToTraitCollection:newCollection 
</span><span class='line'>                 withTransitionCoordinator:coordinator];
</span><span class='line'>    [coordinator animateAlongsideTransition:^(id &lt;UIViewControllerTransitionCoordinatorContext&gt; context) 
</span><span class='line'>    {
</span><span class='line'>        if (newCollection.verticalSizeClass == UIUserInterfaceSizeClassCompact) {
</span><span class='line'>            //To Do: modify something for compact vertical size
</span><span class='line'>        } else {
</span><span class='line'>            //To Do: modify something for other vertical size
</span><span class='line'>        }
</span><span class='line'>        [self.view setNeedsLayout];
</span><span class='line'>    } completion:nil];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在两个To Do处，我们要手写代码针对不同的状态做调整。</p>

<h3>Size Classes与Interface Builder</h3>

<p>Xcode6中<code>Interface Builder</code>对<code>Size Class</code>有了很强大的支持，xib中可以开启Size Classes如下图：</p>

<p><img src="http://img.itc.cn/photo/jDaZQyG9GF0" alt="Alt text" /></p>

<p>在不同的<code>Size Classes</code>描述下，界面元素可以选择安装还是不安装，具体操作如图：</p>

<p><img src="http://img.itc.cn/photo/jDaZQbsciH2" alt="Alt text" /></p>

<h3>Size Classes与Image Asset</h3>

<p>Xcode6中<code>Image Asset</code>也支持了<code>Size Class</code>,也就是说,我们可以对不同的<code>Size Class</code>指定不同的图片了。在<code>Image Asset</code>的编辑面板中选择某张图片，Inspector里现在多了一个<code>Width</code>和<code>Height</code>的组合，添加我们需要对应的<code>Size Class</code>，然后把合适的图拖上去，这样在运行时<code>SDK</code>就将从中挑选对应的<code>Size</code>的图进行替换了。支持<code>Size Class</code>的<code>Image Asset</code>编辑效果如下：</p>

<p><img src="http://img.itc.cn/photo/jDaZQ4Vv1TP" alt="Alt text" /></p>

<h3>参考链接</h3>

<ul>
<li><a href="https://developer.apple.com/library/ios/releasenotes/General/WhatsNewIniOS/Articles/iOS8.html">What&rsquo;s New in iOS</a></li>
<li><a href="http://onevcat.com/2014/07/ios-ui-unique/">WWDC 2014 Session笔记 &ndash; iOS界面开发的大一统</a></li>
<li><a href="http://blog.sunnyxx.com/2014/09/09/ios8-size-classes/">iOS8 Size Classes初探</a></li>
</ul>


		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-09-12T18:42:19+08:00" data-updated="true" itemprop="datePublished">Sep 12<span>th</span>, 2014</time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/09/12/objective-c-superde-li-jie/" itemprop="url">Objective-C Super的理解</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h4>1.Super的理解</h4>

<p>先看下面的例子</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface Father : NSObject
</span><span class='line'>@end
</span><span class='line'>@implementation Father
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>@interface Son : Father
</span><span class='line'>@end
</span><span class='line'>@implementation Son
</span><span class='line'>- (id)init
</span><span class='line'>{
</span><span class='line'>    self = [super init];
</span><span class='line'>    if (self)
</span><span class='line'>    {
</span><span class='line'>        NSLog(@"%@", NSStringFromClass([self class]));
</span><span class='line'>        NSLog(@"%@", NSStringFromClass([super class]));
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    return self;
</span><span class='line'>}
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>输出的结果：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Son
</span><span class='line'>Son</span></code></pre></td></tr></table></div></figure>


<p>根据<code>[super class]</code>表面的意思我们很容易理解输出应该为<code>Father</code>。真是的情况是这样的，<code>super</code>只是一个<code>编译器指示符</code>,当使用<code>super</code>和<code>self</code>发送消息的时候，消息的接收者都是<code>self</code>，本质上通过<code>self</code>发送消息会转化成<code>objc_msgSend</code>方法的调用，<code>objc_msgSend</code>负责从当前类的方法列表开始查询，而通过<code>super</code>发送消息会转化成<code>objc_msgSendSuper</code>方法的调用，<code>objc_msgSendSuper</code>是从当前类的父类的方法列表开始查询方法的。
<code>objc_msgSend</code>定义如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>id objc_msgSend(id receiver, SEL op, ...)</span></code></pre></td></tr></table></div></figure>


<p><code>self</code>默认为<code>objc_msgSend</code>方法的第一个参数，所以<code>[self class]</code>的接收者为<code>self</code>，而<code>class</code>方法在<code>NSObject</code>基类中定义，返回消息接收者<code>receiver</code>的。
<code>objc_msgSendSuper</code>定义如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>id objc_msgSendSuper(struct objc_super *super, SEL op, ...)</span></code></pre></td></tr></table></div></figure>


<p>第一个参数是个<code>objc_super</code>的结构体,定义如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct objc_super {
</span><span class='line'>    id receiver; 
</span><span class='line'>    Class superClass;
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>可以看到这个结构体包含了两个成员，一个是<code>receiver</code>，这个类似上面<code>objc_msgSend</code>的第一个参数<code>receiver</code>，第二个成员是记录这个类的父类是什么,构建<code>objc_super</code>的时候第一个参数赋值为<code>self</code>，<code>superClass</code>赋值为<code>self</code>的父类指针。
最上面的例子中<code>[super class]</code>具体执行过程如下：
1.构建<code>objc_super</code>的结构体，此时这个结构体的第一个成员变量receiver就是Son的实例，和self相同。而第二个成员变量superClass就是指类Father。
2.调用<code>objc_msgSendSuper</code>方法，将<code>objc_super</code>结构体和<code>class</code>的<code>sel</code>传递过去。函数里面在做的事情类似这样：从<code>objc_super</code>结构体指向的<code>superClass</code>的方法列表开始找<code>class</code>的<code>selector</code>，找到后再以<code>objc_super-&gt;receiver</code>去调用这个<code>selector</code>，可能也会使用<code>objc_msgSend</code>这个函数，不过此时的第一个参数<code>receiver</code>就是<code>objc_super-&gt;receiver</code>，第二个参数是从<code>objc_super-&gt;superClass</code>中找到的<code>selector</code>。</p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-09-12T18:38:16+08:00" data-updated="true" itemprop="datePublished">Sep 12<span>th</span>, 2014</time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/09/12/id-vs-instancetype/" itemprop="url">Id vs Instancetype</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h3>id存在的问题</h3>

<p>根据Cocoa的命名惯例，Objective-C中init, alloc这类开头的方法，如果以id作为返回类型，会返回消息接收类的实例对象。这些方法有一个<code>相关返回类型</code>，LLVM会进行静态的类型安全检查，但是不是按照这类命名规则命名的方法如果也要返回id，LLVM就不会进行类型安全检查，我们在编译的时候不会发现，而在运行的时候很可能出错，我们现在定义一个类：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface Person : NSObject
</span><span class='line'>- (id)initWithName:(NSString *)name;
</span><span class='line'>+ (id)personName:(NSString *)name;
</span><span class='line'>@end
</span><span class='line'>@implementation Person
</span><span class='line'>- (id)initWithName:(NSString *)name
</span><span class='line'>{
</span><span class='line'>    self = [super init];
</span><span class='line'>    if (self){
</span><span class='line'>    }
</span><span class='line'>    return self;
</span><span class='line'>}
</span><span class='line'>+ (id)personName:(NSString *)name
</span><span class='line'>{
</span><span class='line'>    Person *person = [[Person alloc] init];
</span><span class='line'>    return person;
</span><span class='line'>}
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>由于<code>personName</code>返回id类型，LLVM不会进行类型安全检查，这样我们就有可能写出错误代码而在编译阶段却发现不了，例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[[[Person alloc] initWithName:@"sss"] count];
</span><span class='line'>[[Person personName:@"sss"] count];</span></code></pre></td></tr></table></div></figure>


<p>第一行代码就会给出<code>count</code>方法找不到的错误，而第二行不会，由于<code>count</code>不是Person的方法，而<code>personName</code>返回的是id类型，编译器是不会发现问题，只有当运行的时候才会报错。但是<code>initWithName</code>是按照内存管理命名规则定义的方法，同样是返回id，但是该方法就会进行<code>类型安全检查</code>,在编译的时候就会发现问题。</p>

<h3>instancetype的出现</h3>

<p><code>instancetype</code>只能用作返回类型，使用<code>instancetype</code>,编译器会进行类型安全检查，就会解决以上问题。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (instancetype)initWithName:(NSString *)name;
</span><span class='line'>+ (instancetype)persionName:(NSString *)name;</span></code></pre></td></tr></table></div></figure>


<p>如果方法的返回类型不是该消息接收类的实例，编译器同样会报错。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (instancetype)personName:(NSString *)name
</span><span class='line'>{
</span><span class='line'>    UIView *view = [UIView alloc] init];
</span><span class='line'>    return person;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>如果<code>personName</code>方法的返回类型使用<code>id</code>，编译器是认为该代码是没有问题的，而实际上我们想要的是<code>Person</code>的实例。所以，返回类型实例的方法的返回类型尽量用<code>instancetype</code>,以便尽早的在代码的编译阶段发现问题。</p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-05-16T10:07:03+08:00" data-updated="true" itemprop="datePublished">May 16<span>th</span>, 2014</time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/05/16/mei-ge-mac-os-x-ming-ling-xing-yong-hu-ying-dang-zhi-dao-de-ba-ge-zhong-duan-gong-ju/" itemprop="url">每个Mac OS X 命令行用户应当知道的八个终端工具</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>OS X的终端开启了一个强大的UNIX实用工具和脚本的世界。如果你是从Linux迁移过来的，你会发现许多熟悉的命令，工作方式和你所期望的方式一样。但是大部分用户不知道OS X自带了一些其他操作系统没有的基于文本的工具。学习这些Mac上独有应用，可以让你在命令行上更高效，帮助你跨越OS X和UNIX之间的鸿沟。</p>

<h2>1.open</h2>

<p><code>open</code>打开文件、目录和应用。很令人兴奋是不是，其实open真正有用的是作为命令行的双击命令，例如输入：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ open /Applications/Safari.app/</span></code></pre></td></tr></table></div></figure>


<p>Safari就会打开，就像你在Finder中双击了Safari图标一样。</p>

<p>如果我们用<code>open</code>打开一个文件，终端就会尝试用相应的GUI程序加载文件，<code>open screenspot.png</code>会在Preview中打开图片。我们可以通过<code>-a</code>来指定打开的应用，或者<code>-e</code>来打开TextEdit编辑文件。</p>

<p><code>open</code>一个目录将直接在Finder窗口中打开相应的目录，特别打开当前目录<code>open .</code>命令是非常有用的。</p>

<p>请记住，Finder和终端是双向的，我们直接从Finder中拖拽一个文件到命令行，该文件的完整地址就会粘贴到命令行。</p>

<h2>2.pbcopy and pbpaste</h2>

<p>我们可以用这两个命令在命令行里粘贴和复制，当然我们也可以使用鼠标做到这些，但是pbcopy和pbpaste真正的强大之处在于，他们来自于UNIX命令，可以充分利用管道、重定向和能够在脚本中与其他命令相结合的能力。例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ls ~ | pbcopy</span></code></pre></td></tr></table></div></figure>


<p>这条命令会拷贝home目录下的所有文件列表到OS X的剪贴板中。我们也可以很简单的获取文件中的内容：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ pbcopy &lt; blogpost.txt</span></code></pre></td></tr></table></div></figure>


<p>或者疯狂一点的，通过抓取脚本抓取Google涂鸦的连接然后拷贝到剪贴板。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ curl http://www.google.com/doodles#oodles/archive | grep -A5 'latest-doodle on' | grep 'img src' | sed s/.*'&lt;img src="\/\/'/''/ | sed s/'" alt=".*'/''/ | pbcopy</span></code></pre></td></tr></table></div></figure>


<p>通过pbcopy来获取其他命令的输出是一个非常棒的方法，省去了我们滚动屏幕小心翼翼的选择文本啦。这个命令让我们很容易的分享诊断信息。pbcopy和pbpaste还可以用于自动或加速某些类型的任务。举例来说，如果你想的电子邮件的主题行保存到任务列表中，你可以从Mail.app赋值主题然后运行下面的命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ pbpaste &gt;&gt; tasklist.txt</span></code></pre></td></tr></table></div></figure>


<h2>3.mdfind</h2>

<p>许多Linux用户尝试在Mac上使用<code>lacate</code>来搜索文件，然后发现这个命令不好使。虽然有一个<code>find</code>命令可以用，但是OSX有一个自己的好用的文件搜索工具<code>Spotlight</code>。所以为什么不把它放到命令行里使用呢？<code>mdfind</code>就是这样的命令。任何<code>Spotlight</code>可以查找的，<code>mdfind</code>都可以查找，包括查找文件和元数据。<code>mdfind</code>有几个方便之处区别于<code>Spotlight</code>。例如<code>-onlyin</code>参数可以严格搜索一个简单的目录：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ mdfind -onlyin ~/Documents essay</span></code></pre></td></tr></table></div></figure>


<p><code>mdfind</code>的数据库总是在后台保持最新，但是我们也可以通过<code>mdutil</code>来重构。如果Spotlight出了问题，<code>mdutil -E</code>可以删除所有索引然后重头重构。我们也可以通过<code>mdutil</code>完全的关闭索引。</p>

<h2>4.screencapture</h2>

<p><code>screencapture</code>可以获取不同类型的截图，功能类似于<code>Grab.app</code>和快捷键<code>cmd</code>+<code>shift</code>+<code>3</code>和<code>cmd</code>+<code>shift</code>+<code>4</code>，但是更灵活。下面展示几种<code>screencapture</code>不同的用法。</p>

<p>1.捕捉屏幕上的内容，包括光标，然后生成的图像（命名为“image.png”）并附加到新的邮件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ screencapture -C -M image.png</span></code></pre></td></tr></table></div></figure>


<p>2.用鼠标选中一个窗口，获取窗口内容不包括阴影，然后拷贝到剪切板：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ screencapture -c -W</span></code></pre></td></tr></table></div></figure>


<p>3.10秒后获取屏幕截图，然后在<code>Preview</code>中打开：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ screencapture -T 10 -P image.png</span></code></pre></td></tr></table></div></figure>


<p>用鼠标选择屏幕的一个区域，然后截图，保存图片为<code>PDF</code>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ screencapture -s -t pdf image.pdf</span></code></pre></td></tr></table></div></figure>


<p>更过选项请查看<code>screencapture --help</code></p>

<h2>5.launchctl</h2>

<p><code>launchctl</code>可以让我们和OS X的初始化脚本系统<code>launch</code>进行交互。随着启动保护进程和启动代理，当我们启动电脑的时候控制要开启的服务。我们甚至可以启动一个脚本定期执行或者一定时间间隔后在后台执行，类似于<code>Linux</code>上的<code>cron</code>。例如你想要在开启电脑的时候自动开启<code>Apache Web Server</code>，你可以这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo launchctl load -w 
</span><span class='line'>/System/Library/LaunchDaemons/org.apache.httpd.plist</span></code></pre></td></tr></table></div></figure>


<p>运行<code>launchctl list</code>我们可以看到当前系统加载的启动脚本。<code>sudo launchctl unload [path/to/script]</code>命令可以停止或者卸载启动脚本，加入<code>-W</code>标志将从启动序列中永久删除这些脚本。我们可以用这个命令关掉<code>Adobe</code>和<code>Microsoft Office</code>的自动更新。启动脚本存储在以下目录下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>~/Library/LaunchAgents    
</span><span class='line'>/Library/LaunchAgents          
</span><span class='line'>/Library/LaunchDaemons
</span><span class='line'>/System/Library/LaunchAgents
</span><span class='line'>/System/Library/LaunchDaemons</span></code></pre></td></tr></table></div></figure>


<p>如果你自己想写启动脚本，Apple在开发者网站上提供了帮助文档。如果你想完全避免命令行来操作的话可以使用Lingon应用。</p>

<h2>6.say</h2>

<p>这是一个有趣的命令：<code>say</code>可以把文本转化成语音，使用和OS X系统VoiceOver相同的TTS引擎，没有任何选项，就是简单的把文本转化为语音说出来。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ say "Never trust a computer you can't lift."</span></code></pre></td></tr></table></div></figure>


<p>我们也可以简单的用<code>say</code>的<code>-f</code>标志来说一个文本内容，然后使用<code>-o</code>存储最后的音频文件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ say -f mynovel.txt -o myaudiobook.aiff</span></code></pre></td></tr></table></div></figure>


<p><code>say</code>命令非常有用可以用来替代脚本里面的打印日志和警告音。例如，你可以设置一个Automator的或Hazel脚本做文件批处理，然后在任务完成的时候通过<code>say</code>宣布。但是对于<code>say</code>最有趣的功能是：如果你可以使用ssh登录朋友的或者同事的机器，你可以默默的登录他们的机器然后通过命令行打扰他们。给他们一个惊喜。我们也可以改变<code>say</code>命令默认的语言，通过<code>System Preferences</code>的<code>Dictation &amp; Speech</code>面板。</p>

<h2>7.diskutil</h2>

<p><code>diskutil</code>是OS X自带磁盘工具对应的命令行工具，它不仅可以做到界面工具可以做到的任何功能，也有一些额外的功能-例如用零或者随机数据填充一个磁盘。输入<code>diskutil list</code>就可以看到计算机相关的可移动介质和磁盘的路径。然后可以查看你操作的磁盘的容量，但是使用<code>diskutil</code>一定要小心，它可能会破坏数据。</p>

<h2>8.brew</h2>

<p>技术上来说<code>brew</code>不是一个原生的命令，但是没有一个Mac高级用户不用<a href="http://brew.sh/">Homebrew</a>,官网生成这是OS X缺少的包管理工具，如果你在Linux上使用过apt-get，那么Homebrew就是这样的工具。
<code>brew</code>可以帮助你轻松的访问开源社区上千的开源库和免费工具，举个例子：<code>brew install imagemagick</code>会帮助你安装<a href="http://www.imagemagick.org/">ImageMagick</a>工具，一个非常有用的工具，可以把GIF图像转换成几十张不同类型的图像。<code>brew install node</code>就会安装<a href="http://nodejs.org/">NodeJS</a>,一个非常热门的JavaScript服务端开发的工具。你也可以用<code>brew</code>做一些有趣的事情：<code>brew install archey</code> 安装<strong>Archey</strong>，一个很cool的工具用来展示Mac描述，包含一个彩色的Apple的Logo。Homebrew的定制是非常灵活的，因为它是非常容易的创建<a href="https://github.com/Homebrew/homebrew/wiki/Formula-Cookbook">formulas</a>,新包会一直被加进来。</p>

<p><img src="http://img.itc.cn/photo/jZcv9irp8EW" alt="" /></p>

<p>但是Homebrew最好的部分是：它总是把所有的文件保存在一个简单的目录下：<code>/usr/local/</code>.这意味着你可以系统软件的最新版本，例如<code>python</code>和<code>mysql</code>，不用被环境变量干扰。如果你不想用Homebrew安装，删除是很简单的。</p>

<h3>原文链接</h3>

<p><a href="http://www.mitchchn.me/2014/os-x-terminal/">Eight Terminal Utilities Every OS X Command Line User Should Know</a></p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-04-22T11:00:11+08:00" data-updated="true" itemprop="datePublished">Apr 22<span>nd</span>, 2014</time></div>
		<div class="tags">

</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/04/22/ios-dev-blogs/" itemprop="url">iOS Dev Blogs</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h2>0.Swift开发</h2>

<ul>
<li><a href="http://swiftist.org/">Swiftist社区</a></li>
<li><a href="http://swift.sh">SwiftChina</a></li>
<li><a href="http://weekly.manong.io/issues/33">Swift特刊</a></li>
<li><a href="http://www.learnswift.tips/">LearnSwiftTis</a></li>
<li><a href="http://www.swiftv.cn/school">Swift课堂(视频)</a></li>
</ul>


<h2>1.国内iOS开发博客</h2>

<ul>
<li>唐巧的技术博客 <a href="http://blog.devtang.com/">http://blog.devtang.com/</a></li>
<li>OneV&rsquo;s Den <a href="http://www.onevcat.com/">http://www.onevcat.com/</a></li>
<li>破船之家 <a href="http://beyondvincent.com/">http://beyondvincent.com/</a></li>
<li>念茜的博客 <a href="http://blog.csdn.net/yiyaaixuexi/">http://blog.csdn.net/yiyaaixuexi/</a></li>
<li>hrchen&rsquo;s blogging <a href="http://www.hrchen.com/">http://www.hrchen.com/</a></li>
<li>代码手工艺人 <a href="http://joeyio.com/">http://joeyio.com/</a></li>
<li>Limboy | 无网不剩 <a href="http://blog.leezhong.com/">http://blog.leezhong.com/</a></li>
<li>txx&rsquo;s blog <a href="http://blog.t-xx.me/">http://blog.t-xx.me/</a></li>
<li>I&rsquo;m Allen <a href="http://imallen.com/">http://imallen.com/</a></li>
<li>萧宸宇 <a href="http://iiiyu.com/">http://iiiyu.com/</a></li>
<li>吴发伟的技术博客 <a href="http://wufawei.com/">http://wufawei.com/</a></li>
<li>董宝君的iOS技术博客 <a href="http://blog.devdong.com/">http://blog.devdong.com/</a></li>
<li>NICO &ndash; Home <a href="http://www.taofengping.com/">http://www.taofengping.com/</a></li>
<li>罗朝辉（飘飘白云）<a href="http://blog.csdn.net/kesalin">http://blog.csdn.net/kesalin</a></li>
<li>JasonLee的专栏 <a href="http://blog.csdn.net/jasonblog">http://blog.csdn.net/jasonblog</a></li>
<li>摇滚诗人 <a href="http://www.cnblogs.com/biosli/">http://www.cnblogs.com/biosli/</a></li>
<li>webfrogs <a href="http://webfrogs.me/">http://webfrogs.me/</a></li>
<li>会写代码的猪 <a href="http://gaosboy.com/">http://gaosboy.com/</a></li>
</ul>


<h2>2.国内iOS开发网站</h2>

<ul>
<li>objc中国 <a href="http://objccn.io/">http://objccn.io/</a></li>
<li>iOS技术分享 <a href="http://www.ios-wiki.com/#">http://www.ios-wiki.com/#</a></li>
</ul>


<h2>3.国外iOS开发博客</h2>

<ul>
<li>NSBlog <a href="https://mikeash.com/pyblog/">https://mikeash.com/pyblog/</a></li>
<li>NSHipster <a href="http://nshipster.com/">http://nshipster.com/</a></li>
</ul>


<h2>4.国外iOS开发网站</h2>

<ul>
<li>objc <a href="http://www.objc.io/">http://www.objc.io/</a></li>
<li>RAYWENDERLICH <a href="http://www.raywenderlich.com/">http://www.raywenderlich.com/</a></li>
</ul>


<h2>5.iOS逆向工程</h2>

<ul>
<li>关注专栏iOS应用逆向工程 | <a href="http://zhuanlan.zhihu.com/iOSRe">http://zhuanlan.zhihu.com/iOSRe</a></li>
</ul>


<h2>6.其他</h2>

<ul>
<li>老谭 <a href="http://www.tanhao.me/">http://www.tanhao.me/</a> Mac开发</li>
<li><p>lianxu.me <a href="http://lianxu.me/">http://lianxu.me/</a> Mac开发</p></li>
<li><p>MacTalk-池建强的随想录 <a href="http://macshuo.com/">http://macshuo.com/</a></p></li>
<li>阮一峰的网络日志 <a href="http://www.ruanyifeng.com/blog/">http://www.ruanyifeng.com/blog/</a></li>
</ul>


		
		
	</div>

</article>

</div>
<nav id="pagenavi">
    
    
        <a href="/blog/page/2/" class="next">Next</a>
    
    <div class="center"><a href="/blog/archives">所有文章</a></div>
</nav>
</div>
			</div>
			<footer id="footer" class="inner">Copyright &copy; 2016

    Joywii


Design credit: <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
</footer>
			<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->



<script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

                  ga('create', 'UA-50708532-1', 'joywii.github.io');
                    ga('send', 'pageview');

</script>
<!--

-->



		</div>
	</div>
</body>
</html>
